/***************************************************************************//**
 * @file
 * @brief	Logic for discrete Light Barrier - Type 2
 * @author	Peter Loës
 * @version	2016-11-18
 *
 * This module provides the logic for the light barriers of type 2.  With this
 * implementation, the PWM signal for the IR LEDs is generated by an EFM32
 * timer, and LETIMER0 is used to enable the circuitry just for an adjustable
 * amount of time to save power.
 *
 * An interrupt service routine checks the current state of the light barrier
 * beams and calls an externally provided function to introduce any signal
 * changes.  Prototype of this function:
 *
 * @code
 * void LP2_SignalState (int num, bool state)
 * @endcode
 *
 * Parameter <i>num</i> contains the index of the two light barriers: 0 for
 * LB1, and 1 for LB2.
 *
 * Parts of the code are based on the example code of AN0026 "LETIMER demo
 * application, PWM and pulse output" from Energy Micro AS.
 *
 ***************************************************************************//**
 *
 * Parts are Copyright 2013 Energy Micro AS, http://www.energymicro.com
 *
 *******************************************************************************
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 * 1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software.
 * 2. Altered source versions must be plainly marked as such, and must not be
 *    misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 * 4. The source and compiled code may only be used on Energy Micro "EFM32"
 *    microcontrollers and "EFR4" radios.
 *
 * DISCLAIMER OF WARRANTY/LIMITATION OF REMEDIES: Energy Micro AS has no
 * obligation to support this Software. Energy Micro AS is providing the
 * Software "AS IS", with no express or implied warranties of any kind,
 * including, but not limited to, any implied warranties of merchantability
 * or fitness for any particular purpose or warranties against infringement
 * of any proprietary rights of a third party.
 *
 * Energy Micro AS will not be liable for any consequential, incidental, or
 * special damages, or any other relief, or for any claim by any third party,
 * arising from your use of this Software.
 *
 ****************************************************************************//*
Revision History:
2016-11-18,rage	Changes for hardware platform Light_Barrier_2015_3:
		- Support 2nd light barrier on PD3.
		- The signal to enable the IR receivers is now high-active.
2016-06-22,rage	Extracted code from main to build this module.
2016-03-23,Loës	Initial version.
*/

/*=============================== Header Files ===============================*/

#include "em_cmu.h"
#include "em_gpio.h"
#include "em_letimer.h"
#include "em_timer.h"

#include "LightBarrier2.h"

/*=============================== Definitions ================================*/

#define TIMER_TOP_VALUE (CMU_ClockFreqGet(cmuClock_HFPER) / LB2_PWM_FREQ)
#define POWER_ON_COMP_VALUE (LETIMER_COUNTS_PER_SEC * LB2_POWER_ON / 1000)
#define POWER_OFF_COMP_VALUE (LETIMER_COUNTS_PER_SEC * LB2_POWER_OFF / 1000)

/*================================ Local Data ================================*/

/* previous state of the light barriers */
static int l_prevLB1_State;
static int l_prevLB2_State;

/*=========================== Forward Declarations ===========================*/

static void PWM_TimerSetup(void);
static void LETIMER0_setup(void);


/***************************************************************************//**
 *
 * @brief	Initialize the light barrier hardware of type 2
 *
 * This routine initializes the board-specific hardware for the light
 * barrier of type 2.  With this implementation of a light barrier, the PWM
 * signal for the IR LED ist generated by an EFM32 timer, and LETIMER0 is
 * used to enable the circuitry just for a adjustable amount of time to save
 * power.
 *
 ******************************************************************************/
void	LB2_Init (void)
{
    /* Be sure to enable clock to GPIO (should already be done) */
    CMU_ClockEnable (cmuClock_GPIO, true);

    /* Initialize the GPIO for the input signal from the IR receivers */
    GPIO_PinModeSet(IR1_RX_INP_PORT, IR1_RX_INP_PIN, gpioModeInput, 0);
    GPIO_PinModeSet(IR2_RX_INP_PORT, IR2_RX_INP_PIN, gpioModeInput, 0);

    l_prevLB1_State = (-1);	// force initial calling of LP2_SignalState()
    l_prevLB2_State = (-1);	// same for LB#2

    /* Setup PWM timer for the IR LED */
    PWM_TimerSetup();

    /* Initialize LETIMER0 */
    LETIMER0_setup();
}

/**************************************************************************//**
 * @brief  TIMER_setup
 * The Timer0 trigger the Infrared LED with 38kHz via p_channel_ mosfet
 * Configures and starts the TIM0_CC1 #3
 *****************************************************************************/
static void PWM_TimerSetup(void)
{
    /* Enable clock for GPIO module should already be done)*/
    CMU_ClockEnable(cmuClock_GPIO, true);

    /* Enable clock for TIMER0 module */
    CMU_ClockEnable(IR_LED_CMU_CLOCK, true);

    /* Set CCx location pin (PD1) as output */
    GPIO_PinModeSet(IR_LED_PORT, IR_LED_PIN, gpioModePushPull, 0);

    /* Select CC channel parameters */
    const TIMER_InitCC_TypeDef timerCCInit =
    {
	.eventCtrl  = timerEventEveryEdge,
	.edge       = timerEdgeBoth,
	.prsSel     = timerPRSSELCh0,
	.cufoa      = timerOutputActionNone,
	.cofoa      = timerOutputActionNone,
	.cmoa       = timerOutputActionToggle,
	.mode       = timerCCModePWM,
	.filter     = false,
	.prsInput   = false,
	.coist      = false,
	.outInvert  = false,
    };

    /* Configure CC channel */
    TIMER_InitCC(IR_LED_TIMER, IR_LED_CC_NUM, &timerCCInit);

    /* Route CC IR_LED_CC_NUM to location IR_LED_CC_LOC and enable pin */
    IR_LED_TIMER->ROUTE |= (IR_LED_CC_PEN | IR_LED_CC_LOC);

    /* Set Top Value */
    TIMER_TopSet(IR_LED_TIMER, TIMER_TOP_VALUE);

    /* PWM with 50 percent duty cycle requires half of TIMER_TOP_VALUE */
    TIMER_CompareBufSet(IR_LED_TIMER, IR_LED_CC_NUM, TIMER_TOP_VALUE/2);

    /* Select timer parameters */
    const TIMER_Init_TypeDef timerInit =
    {
	.enable     = true,
	.debugRun   = true,
	.prescale   = timerPrescale1,
	.clkSel     = timerClkSelHFPerClk,
	.fallAction = timerInputActionNone,
	.riseAction = timerInputActionNone,
	.mode       = timerModeUp,
	.dmaClrAct  = false,
	.quadModeX4 = false,
	.oneShot    = false,
	.sync       = false,
    };

    /* Configure timer */
    TIMER_Init(IR_LED_TIMER, &timerInit);
}

/**************************************************************************//**
 * @brief  LETIMER_setup
 *
 * The LETIMER is switching the Infrared receivers via MOS-FET T2.  This
 * happens every 100ms for about 6ms.
 *
 * LETIMER0 is a down-counter, i.e. it starts with a value stored in COMP0,
 * and counts down until 0 is reached.  It then reloads from COMP0 and starts
 * again.  When the counter has reached COMP1 value, the IR circuitry is
 * enabled for the remaining time until 0 is reached.
 *****************************************************************************/
static void LETIMER0_setup(void)
{
    /* Enable clock for GPIO module should already be done)*/
    CMU_ClockSelectSet(cmuClock_LFA, cmuSelect_LFXO);
    CMU_ClockEnable(cmuClock_CORELE, true);
    CMU_ClockEnable(cmuClock_LETIMER0, true);
    CMU_ClockEnable(cmuClock_GPIO, true);

    /* light barrier infrared receiver enable output */
    GPIO_PinModeSet(IR_RX_ENA_PORT, IR_RX_ENA_PIN, gpioModePushPull, 0);

    /* Reset LETIMER0, set default values for registers */
    LETIMER_Reset(LETIMER0);

    /*
     * Set initial compare values for COMP0 and COMP1.  COMP0 keeps it's value
     * and is used as TOP value for the LETIMER.  Since it is a down-counter we
     * load POWER_ON_COMP_VALUE to COMP1 to generate an interrupt when just as
     * many cycles are "left over" until the counter reaches 0 and reloads.
     */
    LETIMER_CompareSet(LETIMER0, 0, POWER_ON_COMP_VALUE + POWER_OFF_COMP_VALUE);
    LETIMER_CompareSet(LETIMER0, 1, POWER_ON_COMP_VALUE);

    /* Set configurations for LETIMER 0 */
    const LETIMER_Init_TypeDef letimerInit =
    {
	.enable         = true,		/* Start counting when init completed. */
	.debugRun       = false,	/* Counter shall not keep running during debug halt. */
	.rtcComp0Enable = false,	/* Don't start counting on RTC COMP0 match. */
	.rtcComp1Enable = false,	/* Don't start counting on RTC COMP1 match. */
	.comp0Top       = true,		/* Load COMP0 register into CNT when counter underflows. COMP0 is used as TOP */
	.bufTop         = false,	/* Don't load COMP1 into COMP0 when REP0 reaches 0. */
	.out0Pol        = 0,		/* Idle value for output 0. */
	.out1Pol        = 0,		/* Idle value for output 1. */
	.ufoa0          = letimerUFOAPwm,	/* PWM interrupt on output 0 */
	.ufoa1          = letimerUFOANone,	/* no action on output 1*/
	.repMode        = letimerRepeatFree	/* Count until stopped */
    };

    /* Initialize LETIMER */
    LETIMER_Init(LETIMER0, &letimerInit);

    /* Enable interrupts for underflow and COMP1 */
    LETIMER_IntEnable(LETIMER0, LETIMER_IEN_UF|LETIMER_IEN_COMP1);
    NVIC_EnableIRQ(LETIMER0_IRQn);
}

/**************************************************************************//**
 * @brief LETIMER0_IRQHandler
 * Interrupt Service Routine for LETIMER0.
 *
 * Switches the Light Barrier on for @ref POWER_ON_COMP_VALUE - or off for
 * @ref POWER_OFF_COMP_VALUE clock cycles.  GPIO port @ref IR_RX_ENA_PORT,
 * pin @ref IR_RX_ENA_PIN is set/cleared to switch the receiver on or off.
 * GPIO port @ref IR_LED_PORT, pin @ref IR_LED_PIN is set as output to attach
 * LED modulation signal, or as input to detach.
 * When a change of the light beam at an IR receiver has been detected, the
 * external function LP2_SignalState() is called to introduce this change.
 * Flag g_flgIRQ is set to indicate main loop to keep the system alive, as long
 * as interrupt service routines need to be executed.
 *****************************************************************************/
void LETIMER0_IRQHandler(void)
{
    /* determine reason for this interrupt */
    if (LETIMER_IntGet(LETIMER0) & LETIMER_IF_COMP1)
    {
	LETIMER_IntClear(LETIMER0, LETIMER_IFC_COMP1);

	/* turn light barrier receiver circuit on */
	GPIO_PinOutSet(IR_RX_ENA_PORT, IR_RX_ENA_PIN);   // high-active
	GPIO_PinModeSet(IR_LED_PORT, IR_LED_PIN, gpioModePushPull, 0);
	Bit(g_EM1_ModuleMask, EM1_MOD_IR_LED_TIMER) = 1; // HF Clock required
    }
    else
    {
	LETIMER_IntClear(LETIMER0, LETIMER_IFC_UF);

	/* sample receiver circuit signals at end of ON time */
	int LB1_State = GPIO_PinInGet(IR1_RX_INP_PORT, IR1_RX_INP_PIN);
	int LB2_State = GPIO_PinInGet(IR2_RX_INP_PORT, IR2_RX_INP_PIN);

	/* turn light barrier receiver circuit off */
	GPIO_PinOutClear(IR_RX_ENA_PORT, IR_RX_ENA_PIN); // high-active
	GPIO_PinModeSet(IR_LED_PORT, IR_LED_PIN, gpioModeInput, 0);
	Bit(g_EM1_ModuleMask, EM1_MOD_IR_LED_TIMER) = 0; // HF Clock NOT required

	/* call external routine to signal new state */
	if (LB1_State != l_prevLB1_State)
	{
	    l_prevLB1_State = LB1_State;
	    LP2_SignalState (0, (bool)LB1_State);
	}
	if (LB2_State != l_prevLB2_State)
	{
	    l_prevLB2_State = LB2_State;
	    LP2_SignalState (1, (bool)LB2_State);
	}
    }

    g_flgIRQ = true;		// Interrupt happened
}
